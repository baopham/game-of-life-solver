{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///game-of-life-solver.min.js","webpack:///webpack/bootstrap d9c9c7b583bf0e59cfae","webpack:///./src/index.js","webpack:///./src/game-of-life.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_gameOfLife","_gameOfLife2","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","Array","isArray","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","GameOfLife","board","alive","JSON","parse","stringify","originalAliveCoords","clone","aliveCoords","allDeadNeighbours","y","parseInt","xHash","x","neighbourCoords","getNeighbourCoords","aliveNeighbourCount","getAliveNeighbourCount","removeFromAliveCoords","n","_neighbourCoords$n","_x","_y","numcols","numrows","isCellAlive","_key","coords","split","_x2","_y2","addToAliveCoords","keys","lengh","_neighbourCoords$i","neighbourX","neighbourY"],"mappings":"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","file":"game-of-life-solver.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"game-of-life-solver\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"game-of-life-solver\"] = factory();\n\telse\n\t\troot[\"game-of-life-solver\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"game-of-life-solver\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"game-of-life-solver\"] = factory();\n\telse\n\t\troot[\"game-of-life-solver\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _gameOfLife = __webpack_require__(1);\n\t\n\tvar _gameOfLife2 = _interopRequireDefault(_gameOfLife);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _gameOfLife2.default;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GameOfLife = function () {\n\t\n\t  /**\n\t   * @param object board\n\t   *\n\t   * e.g:\n\t   * {\n\t   *   numrows: 10,\n\t   *   numcols: 10,\n\t   *   aliveCoords: {\n\t   *     5: {9: null, 10: null, 11: null}, // {y: {x1: null, x2: null ...}}\n\t   *   }\n\t   * }\n\t   */\n\t\n\t  function GameOfLife(board) {\n\t    _classCallCheck(this, GameOfLife);\n\t\n\t    this.board = board;\n\t    this.alive = null;\n\t  }\n\t\n\t  _createClass(GameOfLife, [{\n\t    key: 'clone',\n\t    value: function clone(obj) {\n\t      return JSON.parse(JSON.stringify(obj));\n\t    }\n\t\n\t    /**\n\t     * Rules:\n\t     * 1) Any live cell with fewer than two live neighbours dies, as if caused by under-population.\n\t     * 2) Any live cell with two or three live neighbours lives on to the next generation.\n\t     * 3) Any live cell with more than three live neighbours dies, as if by overcrowding.\n\t     * 4) Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\n\t     */\n\t\n\t  }, {\n\t    key: 'nextGeneration',\n\t    value: function nextGeneration() {\n\t      this.originalAliveCoords = this.clone(this.board.aliveCoords);\n\t      this.alive = 0;\n\t\n\t      var allDeadNeighbours = {};\n\t\n\t      // Loop through alive coords.\n\t      for (var y in this.board.aliveCoords) {\n\t        // Get hash of all x coords with the same y coord.\n\t        y = parseInt(y, 10);\n\t        var xHash = this.board.aliveCoords[y];\n\t\n\t        for (var x in xHash) {\n\t          x = parseInt(x, 10);\n\t          var neighbourCoords = this.getNeighbourCoords(x, y);\n\t\n\t          var aliveNeighbourCount = this.getAliveNeighbourCount(x, y, neighbourCoords);\n\t\n\t          // Under-population or overcrowding...\n\t          if (aliveNeighbourCount < 2 || aliveNeighbourCount > 3) {\n\t            this.removeFromAliveCoords(x, y, this.board.aliveCoords);\n\t          } else {\n\t            this.alive++;\n\t          }\n\t\n\t          // Keep count of dead neighbours.\n\t          for (var n = 0; n < neighbourCoords.length; n++) {\n\t            var _neighbourCoords$n = _slicedToArray(neighbourCoords[n], 2);\n\t\n\t            var _x = _neighbourCoords$n[0];\n\t            var _y = _neighbourCoords$n[1];\n\t\n\t\n\t            if (_x >= this.board.numcols || _x < 0) continue;\n\t            if (_y >= this.board.numrows || _y < 0) continue;\n\t\n\t            if (!this.isCellAlive(_x, _y, this.originalAliveCoords)) {\n\t              var key = _x + ',' + _y;\n\t\n\t              if (allDeadNeighbours[key] === undefined) {\n\t                allDeadNeighbours[key] = 0;\n\t              }\n\t\n\t              allDeadNeighbours[key]++;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      // Check for reproduction case.\n\t      for (var _key in allDeadNeighbours) {\n\t        if (allDeadNeighbours[_key] === 3) {\n\t          var coords = _key.split(',');\n\t\n\t          var _x2 = parseInt(coords[0], 10);\n\t\n\t          var _y2 = parseInt(coords[1], 10);\n\t\n\t          this.addToAliveCoords(_x2, _y2, this.board.aliveCoords);\n\t          this.alive++;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'isCellAlive',\n\t    value: function isCellAlive(x, y, aliveCoords) {\n\t      return aliveCoords[y] !== undefined && aliveCoords[y][x] !== undefined;\n\t    }\n\t  }, {\n\t    key: 'addToAliveCoords',\n\t    value: function addToAliveCoords(x, y, aliveCoords) {\n\t      if (aliveCoords[y] === undefined) {\n\t        aliveCoords[y] = {};\n\t      }\n\t\n\t      aliveCoords[y][x] = null;\n\t    }\n\t  }, {\n\t    key: 'removeFromAliveCoords',\n\t    value: function removeFromAliveCoords(x, y, aliveCoords) {\n\t      delete aliveCoords[y][x];\n\t\n\t      if (Object.keys(aliveCoords[y]).lengh === 0) {\n\t        delete this.board.aliveCoords[y];\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getNeighbourCoords',\n\t    value: function getNeighbourCoords(x, y) {\n\t      var neighbourCoords = [[x - 1, y - 1], [x, y - 1], [x, y + 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1], [x - 1, y], [x - 1, y + 1]];\n\t\n\t      return neighbourCoords;\n\t    }\n\t  }, {\n\t    key: 'getAliveNeighbourCount',\n\t    value: function getAliveNeighbourCount(x, y, neighbourCoords) {\n\t      var aliveNeighbourCount = 0;\n\t\n\t      for (var i = 0; i < neighbourCoords.length; i++) {\n\t        var _neighbourCoords$i = _slicedToArray(neighbourCoords[i], 2);\n\t\n\t        var neighbourX = _neighbourCoords$i[0];\n\t        var neighbourY = _neighbourCoords$i[1];\n\t\n\t\n\t        if (this.isCellAlive(neighbourX, neighbourY, this.originalAliveCoords)) {\n\t          aliveNeighbourCount++;\n\t        }\n\t      }\n\t\n\t      return aliveNeighbourCount;\n\t    }\n\t  }]);\n\t\n\t  return GameOfLife;\n\t}();\n\n\texports.default = GameOfLife;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** game-of-life-solver.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d9c9c7b583bf0e59cfae\n **/","import GameOfLife from 'game-of-life'\n\nexport default GameOfLife\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/index.js\n **/","export default class GameOfLife {\n\n  /**\n   * @param object board\n   *\n   * e.g:\n   * {\n   *   numrows: 10,\n   *   numcols: 10,\n   *   aliveCoords: {\n   *     5: {9: null, 10: null, 11: null}, // {y: {x1: null, x2: null ...}}\n   *   }\n   * }\n   */\n  constructor (board) {\n    this.board = board\n    this.alive = null\n  }\n\n  clone (obj) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n\n  /**\n   * Rules:\n   * 1) Any live cell with fewer than two live neighbours dies, as if caused by under-population.\n   * 2) Any live cell with two or three live neighbours lives on to the next generation.\n   * 3) Any live cell with more than three live neighbours dies, as if by overcrowding.\n   * 4) Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\n   */\n  nextGeneration () {\n    this.originalAliveCoords = this.clone(this.board.aliveCoords)\n    this.alive = 0\n\n    let allDeadNeighbours = {}\n\n    // Loop through alive coords.\n    for (let y in this.board.aliveCoords) {\n      // Get hash of all x coords with the same y coord.\n      y = parseInt(y, 10)\n      let xHash = this.board.aliveCoords[y]\n\n      for (let x in xHash) {\n        x = parseInt(x, 10)\n        let neighbourCoords = this.getNeighbourCoords(x, y)\n\n        let aliveNeighbourCount = this.getAliveNeighbourCount(x, y, neighbourCoords)\n\n        // Under-population or overcrowding...\n        if (aliveNeighbourCount < 2 || aliveNeighbourCount > 3) {\n          this.removeFromAliveCoords(x, y, this.board.aliveCoords)\n        } else {\n          this.alive++\n        }\n\n        // Keep count of dead neighbours.\n        for (let n = 0; n < neighbourCoords.length; n++) {\n          let [x, y] = neighbourCoords[n]\n\n          if (x >= this.board.numcols || x < 0) continue\n          if (y >= this.board.numrows || y < 0) continue\n\n          if (!this.isCellAlive(x, y, this.originalAliveCoords)) {\n            let key = x + ',' + y\n\n            if (allDeadNeighbours[key] === undefined) {\n              allDeadNeighbours[key] = 0\n            }\n\n            allDeadNeighbours[key]++\n          }\n        }\n      }\n    }\n\n    // Check for reproduction case.\n    for (let key in allDeadNeighbours) {\n      if (allDeadNeighbours[key] === 3) {\n        let coords = key.split(',')\n        let [x, y] = [parseInt(coords[0], 10), parseInt(coords[1], 10)]\n\n        this.addToAliveCoords(x, y, this.board.aliveCoords)\n        this.alive++\n      }\n    }\n  }\n\n  isCellAlive (x, y, aliveCoords) {\n    return aliveCoords[y] !== undefined && aliveCoords[y][x] !== undefined\n  }\n\n  addToAliveCoords (x, y, aliveCoords) {\n    if (aliveCoords[y] === undefined) {\n      aliveCoords[y] = {}\n    }\n\n    aliveCoords[y][x] = null\n  }\n\n  removeFromAliveCoords (x, y, aliveCoords) {\n    delete aliveCoords[y][x]\n\n    if (Object.keys(aliveCoords[y]).lengh === 0) {\n      delete this.board.aliveCoords[y]\n    }\n  }\n\n  getNeighbourCoords (x, y) {\n    let neighbourCoords = [\n      [x - 1, y - 1],\n      [x, y - 1],\n      [x, y + 1],\n      [x + 1, y - 1],\n      [x + 1, y],\n      [x + 1, y + 1],\n      [x - 1, y],\n      [x - 1, y + 1]\n    ]\n\n    return neighbourCoords\n  }\n\n  getAliveNeighbourCount (x, y, neighbourCoords) {\n    let aliveNeighbourCount = 0\n\n    for (let i = 0; i < neighbourCoords.length; i++) {\n      let [neighbourX, neighbourY] = neighbourCoords[i]\n\n      if (this.isCellAlive(neighbourX, neighbourY, this.originalAliveCoords)) {\n        aliveNeighbourCount++\n      }\n    }\n\n    return aliveNeighbourCount\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/game-of-life.js\n **/"],"sourceRoot":""}